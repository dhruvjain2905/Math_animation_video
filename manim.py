# -*- coding: utf-8 -*-
"""Manim

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iZn0KZGaa289b-SMKIH5YPPk4suYA6wf
"""

!sudo apt update
!sudo apt install libcairo2-dev ffmpeg texlive texlive-latex-extra texlive-fonts-extra texlive-latex-recommended texlive-science tipa libpango1.0-dev
!pip install manim
!pip install IPython --upgrade

from manim import *

# Commented out IPython magic to ensure Python compatibility.
# %manim --help

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh SquareToCircle
# 
# class SquareToCircle(Scene):
#     def construct(self):
#         circle = Circle()  # create a circle
#         circle.set_fill(PINK, opacity=0.5)  # set color and transparency
# 
#         square = Square()  # create a square
#         square.rotate(PI / 4)  # rotate a certain amount
# 
#         self.play(Create(square))  # animate the creation of the square
#         self.play(Transform(square, circle))  # interpolate the square into the circle
#         self.play(FadeOut(square))





# Commented out IPython magic to ensure Python compatibility.
# %%manim MovingFrameBox
# 
# class MovingFrameBox(Scene):
#     def construct(self):
#         text=MathTex(
#             "\\frac{d}{dx}f(x)g(x)=","f(x)\\frac{d}{dx}g(x)","+",
#             "g(x)\\frac{d}{dx}f(x)"
#         )
#         self.play(Write(text))
#         framebox1 = SurroundingRectangle(text[1], buff = .1)
#         framebox2 = SurroundingRectangle(text[3], buff = .1)
#         self.play(
#             Create(framebox1),
#         )
#         self.wait()
#         self.play(
#             ReplacementTransform(framebox1,framebox2),
#         )
#         self.wait()

# Commented out IPython magic to ensure Python compatibility.
# %%manim Tute2
# 
# class Tute2(Scene):  #ILLUSTRATING POLAR PLANE WITH A SINE CURVE
#     def construct(self):
# 
# 
#         e = ValueTracker(0.01) #Tracks the end value of both functions
# 
#         plane = PolarPlane(radius_max=3).add_coordinates()
#         plane.shift(LEFT*2)
#         graph1 = always_redraw(lambda :
#         ParametricFunction(lambda t : plane.polar_to_point(2*np.sin(3*t), t),
#         t_range = [0, e.get_value()], color = GREEN)
#         )
#         dot1 = always_redraw(lambda : Dot(fill_color = GREEN, fill_opacity = 0.8).scale(0.5).move_to(graph1.get_end())
#         )
# 
#         axes = Axes(x_range = [0, 4, 1], x_length=3, y_range=[-3,3,1], y_length=3).shift(RIGHT*4)
#         axes.add_coordinates()
#         graph2 = always_redraw(lambda :
#         axes.get_graph(lambda x : 2*np.sin(3*x), x_range = [0, e.get_value()], color = GREEN)
#         )
#         dot2 = always_redraw(lambda : Dot(fill_color = GREEN, fill_opacity = 0.8).scale(0.5).move_to(graph2.get_end())
#         )
# 
#         title = MathTex("f(\\theta) = 2sin(3\\theta)", color = GREEN).next_to(axes, UP, buff=0.2)
# 
#         self.play(LaggedStart(
#             Write(plane), Create(axes), Write(title),
#             run_time=3, lag_ratio=0.5)
#         )
#         self.add(graph1, graph2, dot1, dot2)
#         self.play(e.animate.set_value(PI), run_time = 10, rate_func = linear)
#         self.wait()

# Commented out IPython magic to ensure Python compatibility.
# %%manim Tute4
# 
# class Tute4(Scene):
#     def construct(self):
# 
#         plane = ComplexPlane(axis_config = {"include_tip": True, "numbers_to_exclude": [0]}).add_coordinates()
# 
#         labels = plane.get_axis_labels(x_label = "Real", y_label="Imaginary")
# 
#         quest = MathTex("Plot \\quad 2-3i").add_background_rectangle().to_edge(UL)
#         dot = Dot()
#         vect1 = plane.get_vector((2,0), stroke_color = YELLOW)
#         vect2 = Line(start = plane.c2p(2,0),
#         end = plane.c2p(2,-3), stroke_color = YELLOW).add_tip()
# 
#         self.play(DrawBorderThenFill(plane), Write(labels))
#         self.wait()
#         self.play(FadeIn(quest))
#         self.play(GrowArrow(vect1), dot.animate.move_to(plane.c2p(2,0)), rate_func = linear, run_time = 2)
#         self.wait()
#         self.play(GrowFromPoint((vect2), point = vect2.get_start()),
#         dot.animate.move_to(plane.c2p(2,-3)), run_time = 2, rate_func = linear)
#         self.wait()

# Commented out IPython magic to ensure Python compatibility.
# %%manim Tute3
# 
# class Tute3(Scene): #Showing how to call 2 planes, put graphs on each and call elements to each
#     def construct(self):
# 
#         backg_plane = NumberPlane(x_range=[-7,7,1], y_range=[-4,4,1])
#         backg_plane.add_coordinates()
# 
#         plane = NumberPlane(x_range = [-4,4,1], x_length = 4,
#         y_range= [0, 20, 5], y_length=4)
#         plane.add_coordinates()
#         plane.shift(LEFT*3+DOWN*1.5)
#         plane_graph = plane.get_graph(lambda x : x**2, x_range = [-4,4], color = GREEN)
#         area = plane.get_riemann_rectangles(graph = plane_graph, x_range=[-2,2], dx=0.05)
# 
#         axes = Axes(x_range = [-4,4,1], x_length = 4,
#         y_range= [-20,20,5], y_length=4)
#         axes.add_coordinates()
#         axes.shift(RIGHT*3+DOWN*1.5)
#         axes_graph = axes.get_graph(lambda x : 2*x,
#         x_range=[-4,4], color = YELLOW)
#         v_lines = axes.get_vertical_lines_to_graph(
#             graph = axes_graph, x_range=[-3,3], num_lines = 12)
# 
#         code = Code("/content/elephant.py", style=Code.styles_list[12], background ="window", language = "python", insert_line_no = True,
#         tab_width = 2, line_spacing = 0.3, scale_factor = 0.5, font="Monospace").set_width(6).to_edge(UL, buff=0)
# 
#         self.play(FadeIn(backg_plane), Write(code), run_time=6)
#         self.play(backg_plane.animate.set_opacity(0.3))
#         self.play(Write(plane), Create(axes))
#         self.wait()
#         self.play(Create(plane_graph), Create(axes_graph), run_time = 2)
#         self.add(area, v_lines)
#         self.wait()

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh Derivatives
# 
# 
# def get_horizontal_line_to_graph(axes, function, x, width, color):
#     result = VGroup()
#     line = DashedLine(
#         start=axes.c2p(0, function.underlying_function(x)),
#         end=axes.c2p(x, function.underlying_function(x)),
#         stroke_width=width,
#         stroke_color=color,
#     )
#     dot = Dot().set_color(color).move_to(axes.c2p(x, function.underlying_function(x)))
#     result.add(line, dot)
#     return result
# 
# 
# def get_arc_lines_on_function(
#     graph, plane, dx=1, line_color=WHITE, line_width=1, x_min=None, x_max=None
# ):
# 
#     dots = VGroup()
#     lines = VGroup()
#     result = VGroup(dots, lines)
# 
#     x_range = np.arange(x_min, x_max, dx)
#     colors = color_gradient([BLUE_B, GREEN_B], len(x_range))
# 
#     for x, color in zip(x_range, colors):
#         p1 = Dot().scale(0.7).move_to(plane.input_to_graph_point(x, graph))
#         p2 = Dot().scale(0.7).move_to(plane.input_to_graph_point(x + dx, graph))
#         dots.add(p1, p2)
#         dots.set_fill(colors, opacity=0.8)
# 
#         line = Line(
#             p1.get_center(),
#             p2.get_center(),
#             stroke_color=line_color,
#             stroke_width=line_width,
#         )
#         lines.add(line)
# 
#     return result
# 
# 
# class Derivatives(Scene):
#     def construct(self):
# 
#         k = ValueTracker(-3)  # Tracking the end values of stuff to show
# 
#         # Adding Mobjects for the first plane
#         plane1 = NumberPlane(x_range=[-3, 4, 1], x_length=5, y_range=[-8, 9, 2], y_length=5)
#         plane1.add_coordinates()
#         plane1.shift(LEFT * 3.5)
# 
#         func1 = plane1.get_graph(lambda x: (1 / 3) * x ** 3, x_range=[-3, 3], color=RED_C)
# 
#         func1_lab = MathTex("f(x)=\\frac{1}{3} {x}^{3}")
#         func1_lab.set(width=2.5)
#         func1_lab.next_to(plane1, UP, buff=0.2)
#         func1_lab.set_color(RED_C)
# 
# 
#         moving_slope = always_redraw(
#             lambda: plane1.get_secant_slope_group(
#                 x=k.get_value(),
#                 graph=func1,
#                 dx=0.05,
#                 secant_line_length=4,
#                 secant_line_color=YELLOW,
#             )
#         )
# 
#         dot = always_redraw(
#             lambda: Dot().move_to(
#                 plane1.c2p(k.get_value(), func1.underlying_function(k.get_value()))
#             )
#         )
# 
#         # Adding Mobjects for the second plane
#         plane2 = NumberPlane(x_range=[-3, 4, 1], x_length=5, y_range=[0, 11, 2], y_length=5)
#         plane2.add_coordinates()
#         plane2.shift(RIGHT * 3.5)
# 
# 
#         func2 = always_redraw(
#             lambda: plane2.get_graph(
#                 lambda x: x ** 2, x_range=[-3, k.get_value()], color=GREEN
#             )
#         )
# 
#         func2_lab = MathTex("f'(x)={x}^{2}")
#         func2_lab.set(width=2.5)
#         func2_lab.next_to(plane2, UP, buff=0.2)
#         func2_lab.set_color(GREEN)
# 
# 
#         moving_h_line = always_redraw(
#             lambda: get_horizontal_line_to_graph(
#                 axes=plane2, function=func2, x=k.get_value(), width=4, color=YELLOW
#             )
#         )
# 
#         # Adding the slope value stuff
#         slope_value_text = (
#             Tex("Slope value: ")
#             .next_to(plane1, DOWN, buff=0.1)
#             .set_color(YELLOW)
#             .add_background_rectangle()
#         )
# 
#         slope_value = always_redraw(
#             lambda: DecimalNumber(num_decimal_places=1)
#             .set_value(func2.underlying_function(k.get_value()))
#             .next_to(slope_value_text, RIGHT, buff=0.1)
#             .set_color(YELLOW)
#         ).add_background_rectangle()
# 
#         # Playing the animation
#         self.play(
#             LaggedStart(
#                 DrawBorderThenFill(plane1),
#                 DrawBorderThenFill(plane2),
#                 Create(func1),
#                 Write(func1_lab),
#                 Write(func2_lab),
#                 run_time=5,
#                 lag_ratio=0.5,
#             )
#         )
#         self.add(moving_slope, moving_h_line, func2, slope_value, slope_value_text, dot)
#         self.play(k.animate.set_value(3), run_time=15, rate_func=linear)
#         self.wait()
# 
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh BoxAnimation
# 
# from manim import *
# 
# class BoxAnimation(Scene):
#   def construct(self):
# 
#     box = Rectangle(stroke_color = YELLOW, stroke_width = 7, fill_color=GREEN, fill_opacity=0.6, height=1.5, width=1.5)
#     self.add(box)
#     self.play(DrawBorderThenFill(box), stroke_width=7)
#     self.play(box.animate.shift(RIGHT*2), run_time=3)
#     self.play(box.animate.shift(DOWN*2+RIGHT*2), run_time=3)

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh Tute34
# 
# class Tute34(Scene):
#     def construct(self):
# 
#         rectangle = RoundedRectangle(stroke_width = 8, stroke_color = WHITE,
#         fill_color = BLUE_B, width = 4.5, height = 2).shift(UP*3+LEFT*4)
# 
#         mathtext = MathTex("\\frac{3}{4} = 0.75"
#         ).set_color_by_gradient(GREEN, PINK).set_height(1.5)
#         mathtext.move_to(rectangle.get_center())
#         mathtext.add_updater(lambda x : x.move_to(rectangle.get_center()))
# 
#         code = Code("/content/t93-000000000043b7d5.txt", style=Code.styles_list[12], background ="window", language = "python", insert_line_no = True,
#                 tab_width = 2, line_spacing = 0.3, scale_factor = 0.5, font="Monospace").set_width(8).to_edge(UR, buff=0)
# 
#         self.play(Write(code), run_time=6)
#         self.wait()
# 
#         self.play(FadeIn(rectangle))
#         self.wait()
#         self.play(Write(mathtext), run_time=2)
#         self.wait()
# 
#         self.play(rectangle.animate.shift(RIGHT*1.5+DOWN*5), run_time=6)
#         self.wait()
#         mathtext.clear_updaters()
#         self.play(rectangle.animate.shift(LEFT*2 + UP*1), run_time=6)
#         self.wait()

# Commented out IPython magic to ensure Python compatibility.
# %%manim Tute43
# 
# class Tute43(Scene):
#     def construct(self):
# 
#         r = ValueTracker(0.5) #Tracks the value of the radius
# 
#         circle = always_redraw(lambda :
#         Circle(radius = r.get_value(), stroke_color = YELLOW,
#         stroke_width = 5))
# 
#         line_radius = always_redraw(lambda :
#         Line(start = circle.get_center(), end = circle.get_bottom(), stroke_color = RED_B, stroke_width = 10)
#         )
# 
#         line_circumference = always_redraw(lambda :
#         Line(stroke_color = YELLOW, stroke_width = 5
#         ).set_length(2 * r.get_value() * PI).next_to(circle, DOWN, buff=0.2)
#         )
# 
#         triangle = always_redraw(lambda :
#         Polygon(circle.get_top(), circle.get_left(), circle.get_right(), fill_color = GREEN_C)
#         )
# 
#         self.play(LaggedStart(
#             Create(circle), DrawBorderThenFill(line_radius), DrawBorderThenFill(triangle),
#             run_time = 4, lag_ratio = 0.75
#         ))
#         self.play(ReplacementTransform(circle.copy(), line_circumference), run_time = 2)
#         self.play(r.animate.set_value(2), run_time = 5)
# 
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim Graphing
# 
# 
# class Graphing(Scene):
#   def construct(self):
#     axes = Axes(x_range=[0,5,1], y_range=[0,3,1], x_length=5, y_length=3)
#     axes.add_coordinates()
#     axes.to_edge(UL, buff=0.5)
#     axes_labels = axes.get_axis_labels(x_label="x", y_label="f(x)")
#     graph = axes.get_graph(lambda x, y: (x**2 + y**2), x_range=[0,4], color=YELLOW)
#     graphing_stuff = VGroup(axes, graph, axes_labels)
# 
#     self.play(DrawBorderThenFill(axes), Write(axes_labels))
#     self.play(Create(graph))
#     self.play(graphing_stuff.animate.shift(DOWN*2+RIGHT*4))

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh Anim2
# 
# 
# 
# class Anim2(Scene):
# 
#   def construct(self):
# 
#     x_val = ValueTracker(0)
# 
#     plane2 = NumberPlane(x_range=[-2.5 , 2.5 , 1], x_length=7, y_range=[-2.5, 2.5, 1], y_length=7)
#     plane2.add_coordinates()
#     plane2.shift(LEFT*3)
#     circle = Circle(radius=(1/5)*7, stroke_color=YELLOW, stroke_width=7)
#     circle.shift(LEFT*3)
#     dot = Dot()
#     dot.shift(LEFT*3)
# 
#     line_sin = always_redraw(lambda : Line(start = (dot.get_x(),0,0), end = (dot.get_x(),dot.get_y(),0), stroke_color = RED, stroke_width=7))
#     line_cos = always_redraw(lambda : Line(start = plane2.get_center(), end = (dot.get_x(),0,0), stroke_color = GREEN, stroke_width=7))
#     line_rad = always_redraw(lambda : Line(start = plane2.get_center(), end = (dot.get_x(),dot.get_y(),0), stroke_color = WHITE, stroke_width=7))
# 
# 
# 
#     axes1 = Axes(x_range = [0, 7, 2], x_length=3, y_range=[-3.5,3.5,2], y_length=3).shift(RIGHT*4+UP*2)
#     axes1.add_coordinates()
#     graph1 = always_redraw(lambda :
#     axes1.get_graph(lambda x : np.sin(x), x_range = [0, x_val.get_value()], color = RED))
# 
#     axes2 = Axes(x_range = [0, 7, 2], x_length=3, y_range=[-3.5,3.5,2], y_length=3).shift(RIGHT*4+DOWN*2)
#     axes2.add_coordinates()
#     graph2 = always_redraw(lambda :
#     axes2.get_graph(lambda x : np.cos(x), x_range = [0, x_val.get_value()], color = GREEN))
# 
#     title = MathTex("f(\\theta) = sin(\\theta)", color = RED).shift(RIGHT*4.8+UP*3.1)
#     title2 = MathTex("f(\\theta) = cos(\\theta)", color = GREEN).shift(RIGHT*4.8+DOWN*0.9)
# 
#     self.play(DrawBorderThenFill(plane2), DrawBorderThenFill(axes1) , DrawBorderThenFill(axes2) , Write(title), Write(title2))
#     self.add(graph1 , graph2)
#     self.play(Create(circle))
#     self.play(Create(line_sin),Create(line_cos),Create(line_rad))
#     self.play(MoveAlongPath(dot, circle), x_val.animate.set_value(2*np.pi), run_time=9, rate_func=linear)
# 
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh Anim3
# 
# 
# 
# class Anim3(Scene):
# 
#   def construct(self):
# 
#     x_val = ValueTracker(0)
# 
#     plane2 = NumberPlane(x_range=[-2.5 , 2.5 , 1], x_length=7, y_range=[-2.5, 2.5, 1], y_length=7)
#     plane2.add_coordinates()
#     plane2.shift(LEFT*3)
#     circle = Circle(radius=(1/5)*7, stroke_color=YELLOW, stroke_width=7)
#     circle.shift(LEFT*3)
#     dot = Dot()
#     dot.shift(LEFT*3)
# 
#     line_sin = always_redraw(lambda : Line(start = (dot.get_x(),0,0), end = (dot.get_x(),dot.get_y(),0), stroke_color = RED, stroke_width=7))
#     #line_cos = always_redraw(lambda : Line(start = plane2.get_center(), end = (dot.get_x(),0,0), stroke_color = GREEN, stroke_width=7))
#     line_rad = always_redraw(lambda : Line(start = plane2.get_center(), end = (dot.get_x(),dot.get_y(),0), stroke_color = WHITE, stroke_width=7))
# 
# 
# 
#     axes1 = Axes(x_range = [0, 7, 2], x_length=3, y_range=[-3.5,3.5,2], y_length=3).shift(RIGHT*4)
#     axes1.add_coordinates()
#     graph1 = always_redraw(lambda :
#     axes1.get_graph(lambda x : np.sin(x), x_range = [0, x_val.get_value()], color = RED))
# 
#     #axes2 = Axes(x_range = [0, 7, 2], x_length=3, y_range=[-3.5,3.5,2], y_length=3).shift(RIGHT*4+DOWN*2)
#     #axes2.add_coordinates()
#     #graph2 = always_redraw(lambda :
#     #axes2.get_graph(lambda x : np.cos(x), x_range = [0, x_val.get_value()], color = GREEN))
# 
#     title = MathTex("f(\\theta) = sin(\\theta)", color = RED).shift(RIGHT*4.8+UP*3.1)
#     title2 = MathTex("f(\\theta) = cos(\\theta)", color = GREEN).shift(RIGHT*4.8+DOWN*0.9)
# 
#     self.play(DrawBorderThenFill(plane2), DrawBorderThenFill(axes1) , Write(title))
#     self.add(graph1)
#     self.play(Create(circle))
#     self.play(Create(line_sin), Create(line_rad))
#     self.play(MoveAlongPath(dot, circle), x_val.animate.set_value(2*np.pi), run_time=15, rate_func=linear)
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh AlmostDo
# import math
# 
# 
# 
# class AlmostDo(Scene):
# 
# 
# 
# 
# 
#   def construct(self):
# 
#     theta_tracker = ValueTracker(math.radians(0.001))
#     plane2 = NumberPlane(x_range=[-1.5 , 1.5 , 1], x_length=7, y_range=[-1.5, 1.5, 1], y_length=7)
#     plane2.add_coordinates()
#     plane2.shift(LEFT*3)
#     circle = Circle(radius=(1/3)*7, stroke_color=YELLOW, stroke_width=7)
#     circle.shift(LEFT*3)
#     #dot = Dot()
#     #dot.shift(LEFT*3)
# 
#     line1 = Line(start = (-3,0,0),end = (-3+(1/3)*7,0,0), color=YELLOW, stroke_width=5)
#     line_moving = always_redraw(lambda: Line(start = (-3,0,0),end = (-3+(1/3)*7,0,0), color=YELLOW, stroke_width=5).rotate(theta_tracker.get_value() , about_point= (-3,0,0)))
# 
#     line_sin = always_redraw(lambda : Line(start = line_moving.get_end(), end = (line_moving.get_end()[0],0,0), stroke_color = RED, stroke_width=7))
#     #line_cos = always_redraw(lambda : Line(start = plane2.get_center(), end = (dot.get_x(),0,0), stroke_color = GREEN, stroke_width=7))
#     #line_rad = always_redraw(lambda : Line(start = plane2.get_center(), end = (dot.get_x(),dot.get_y(),0), stroke_color = WHITE, stroke_width=7))
# 
#     angle = always_redraw(lambda: Angle(line1, line_moving, radius=(1/3)*7, stroke_width=12, stroke_color=WHITE))
#     meas = always_redraw(lambda: MathTex(r"\theta =", round(math.degrees(theta_tracker.get_value())) ,r"^{\circ}"  ).shift(RIGHT*4+UP*1).scale(1.5))
#     val = always_redraw(lambda: MathTex(r"\sin (\theta ) = ", round(math.sin(theta_tracker.get_value()) , 2)).shift(RIGHT*4+DOWN*1).scale(1.5))
# 
# 
#     angle2 = always_redraw(lambda: Angle(line1, line_moving, radius=1, stroke_width=5, color=WHITE))
# 
#     #tex = always_redraw(lambda: MathTex(r"\theta").next_to(angle).shift(RIGHT*0.05+UP*0.15))
# 
# 
#     self.play(DrawBorderThenFill(plane2))
#     self.wait(1.5)
#     #self.add(graph1 , graph2)
#     self.play(Create(circle))
#     self.wait(6)
#     self.play(Write(meas), Write(val))
#     self.play(Create(line1), Create(line_moving), Create(line_sin))
#     self.play(Create(angle), Create(angle2))
#     self.play(theta_tracker.animate.set_value(math.radians(220)), run_time=20)
# 
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh Almost
# import math
# 
# 
# 
# class Almost(Scene):
# 
# 
# 
# 
# 
#   def construct(self):
# 
#     theta_tracker = ValueTracker(math.radians(0.001))
#     plane2 = NumberPlane(x_range=[-1.5 , 1.5 , 1], x_length=7, y_range=[-1.5, 1.5, 1], y_length=7)
#     plane2.add_coordinates()
#     plane2.shift(LEFT*3)
#     circle = Circle(radius=(1/3)*7, stroke_color=YELLOW, stroke_width=7)
#     circle.shift(LEFT*3)
#     #dot = Dot()
#     #dot.shift(LEFT*3)
# 
#     line1 = Line(start = (-3,0,0),end = (-3+(1/3)*7,0,0), color=YELLOW, stroke_width=5)
#     line_moving = always_redraw(lambda: Line(start = (-3,0,0),end = (-3+(1/3)*7,0,0), color=YELLOW, stroke_width=5).rotate(theta_tracker.get_value() , about_point= (-3,0,0)))
# 
#     line_sin = always_redraw(lambda : Line(start = line_moving.get_end(), end = (line_moving.get_end()[0],0,0), stroke_color = RED, stroke_width=7))
#     #line_cos = always_redraw(lambda : Line(start = plane2.get_center(), end = (dot.get_x(),0,0), stroke_color = GREEN, stroke_width=7))
#     #line_rad = always_redraw(lambda : Line(start = plane2.get_center(), end = (dot.get_x(),dot.get_y(),0), stroke_color = WHITE, stroke_width=7))
# 
#     angle = always_redraw(lambda: Angle(line_moving, line1, radius=(1/3)*7, stroke_width=12, stroke_color=WHITE))
#     meas = always_redraw(lambda: MathTex(r"\theta =", round(math.degrees(theta_tracker.get_value())) ,r"^{\circ}"  ).shift(RIGHT*4+UP*1).scale(1.5))
#     val = always_redraw(lambda: MathTex(r"\sin (\theta ) = ", round(math.sin(theta_tracker.get_value()) , 2)).shift(RIGHT*4+DOWN*1).scale(1.5))
# 
# 
#     angle2 = always_redraw(lambda: Angle(line_moving, line1, radius=1, stroke_width=5, color=WHITE))
# 
#     #tex = always_redraw(lambda: MathTex(r"\theta").next_to(angle).shift(RIGHT*0.05+UP*0.15))
# 
# 
#     self.play(DrawBorderThenFill(plane2))
#     self.wait(1.5)
#     #self.add(graph1 , graph2)
#     self.play(Create(circle))
#     self.wait(6)
#     self.play(Write(meas), Write(val))
#     self.play(Create(line1), Create(line_moving), Create(line_sin))
#     self.play(Create(angle), Create(angle2))
#     self.play(theta_tracker.animate.set_value(math.radians(-60)), run_time=5)
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim Pendulum
# 
# from manim import *
# import numpy as np
# 
# class Pendulum(Scene):
# 
#   def construct(self):
#     time = ValueTracker(0)
# 
#     theta_max = 30 / 180 * PI
# 
#     l = 3
#     g = 15
#     w = np.sqrt(g/l)
#     T = 2 * PI / w
# 
#     p_x = 0
#     p_y = 1.2
#     shift_req = p_x* RIGHT + p_y * UP
# 
#     theta = DecimalNumber().set_color(BLACK).move_to(10*RIGHT)
#     theta.add_updater(lambda m: m.set_value((theta_max) * np.sin(w*time.get_value())))
# 
#     self.add(theta)
# 
#     def get_line(x , y):
#       line_here = Line(start = ORIGIN + shift_req, end = x*RIGHT + y* UP + shift_req, color=GREY)
#       global line_vertical
#       line_vertical = DashedLine(start = line_here.get_start(), end = line_here.get_start() + 3 * DOWN, color=GREY)
# 
#       return line_here
# 
#     line = always_redraw(lambda: get_line(l * np.sin(theta.get_value()) , -l * np.cos(theta.get_value()) ))
#     self.add(line)
#     self.add(line_vertical)
# 
# 
#     def angle_arc(theta):
#       global angle
#       global arc_text
#       if theta == 0:
#         angle = VectorizedPoint().move_to(10*RIGHT)
#         arc_text = VectorizedPoint().move_to(10*RIGHT)
#       else:
#         if theta > 0:
#           angle = Angle(line, line_vertical, quadrant=(1,1), other_angle=True, color=YELLOW, fill_opacity=0)
#         elif theta < 0:
#           angle = Angle(line, line_vertical, quadrant=(1,1), other_angle=False, color=YELLOW, fill_opacity=0)
#       return angle
# 
# 
#     angle = always_redraw(lambda: angle_arc(theta.get_value()))
# 
#     self.add(angle)
#     arc_text = Tex(r"$\theta$").scale(0.5)
#     arc_text.add_updater(lambda m: m.next_to(angle, DOWN))
#     self.add(arc_text)
# 
#     def get_ball(x ,y):
#       dot = Dot(fill_color=BLUE, fill_opacity=1).move_to(x*RIGHT + y*UP + shift_req).scale(l)
# 
#       return dot
# 
#     ball = always_redraw(lambda: get_ball(l * np.sin(theta.get_value()) , -l *np.cos(theta.get_value())))
#     self.add(ball)
# 
#     self.play(time.animate.set_value(3*T), rate_func=linear, run_time=3*T)

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh A2
# 
# class A2(Scene):
# 
#   def construct(self):
# 
# 
#     text = MarkupText(f'Trig<span fgcolor="{BLUE}">onometry</span>', color=YELLOW).scale(2)
#     line = Line(stroke_width = 15).shift(UP*1.7)
#     line.set_length(7)
# 
#     arbitrary = Text("- confusing").shift(UP*0.7)
#     opaque = Text("- uintuitive").shift(DOWN*0.3)
#     #unintiutive = Text("- hard to understand").shift(DOWN*1.45)
# 
#     self.play(Write(text), run_time=2)
#     self.wait(2)
#     self.play(text.animate.shift(UP*2.2).scale(0.65))
#     self.play(Create(line))
#     self.play(Write(arbitrary), run_time=1.5)
#     self.play(Write(opaque), run_time=1.5)
#     #self.play(Write(unintiutive))
#     self.wait(2)

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh A3
# 
# class A3(Scene):
# 
#   def construct(self):
# 
#     cah = Text("cah", t2c={"a": YELLOW , "h": RED}).shift(UP*2.1).scale(1.3)
# 
#     soh = Text("soh", t2c={"o": GREEN , "h": RED}).next_to(cah, LEFT*8).scale(1.3)
# 
#     toa = Text("toa", t2c={"o": GREEN , "a": YELLOW}).next_to(cah, RIGHT*8).scale(1.3)
# 
# 
#     line = Line(end=RIGHT*3+UP*0.4, start=LEFT*3+DOWN*3, color=BLACK)
#     line2 = Line(end=RIGHT*3+DOWN*3, start=LEFT*3+DOWN*3, color=BLACK)
# 
#     triangle = Polygon(LEFT*3+DOWN*3,RIGHT*3+DOWN*3, RIGHT*3+UP*0.4, stroke_width=10)
# 
#     rectangle = Square(color = BLUE, stroke_width = 10).shift(RIGHT*2.6+DOWN*2.6).scale(0.4)
# 
#     angle = Angle(line2, line, radius = 1.5, stroke_width = 7, color=YELLOW)
# 
#     tex = MathTex(r"\theta").move_to(angle).shift(RIGHT*0.3+UP*0.1)
# 
#     opp_line = Line(start=RIGHT*3+DOWN*3, end = RIGHT*3+UP*0.4, color = GREEN, stroke_width = 20)
#     hyp_line = Line(start=LEFT*3+DOWN*3, end = RIGHT*3+UP*0.4, color = RED, stroke_width = 20)
#     adj_line = Line(start=LEFT*3+DOWN*3, end = RIGHT*3+DOWN*3, color = YELLOW, stroke_width = 20)
# 
#     eq = MathTex(r"{{\sin}}(\theta) = \dfrac{opposite}{hypotenuse}").shift(LEFT*3)
#     eq[1][4:12].set_color(GREEN)
#     eq[1][13:23].set_color(RED)
#     eq[0].set_color(BLUE)
#     eq[1][0].set_color(BLUE)
#     eq[1][2].set_color(BLUE)
# 
# 
# 
#     eq1 = MathTex(r"{{\cos}}(\theta) = \dfrac{adjacent}{hypotenuse}").shift(LEFT*3)
#     eq1[1][4:12].set_color(YELLOW)
#     eq1[1][13:23].set_color(RED)
#     eq1[0].set_color(BLUE)
#     eq1[1][0].set_color(BLUE)
#     eq1[1][2].set_color(BLUE)
# 
# 
# 
# 
#     eq2 = MathTex(r"{{\tan}}(\theta) = \dfrac{opposite}{adjacent}").shift(LEFT*3)
#     eq2[1][4:12].set_color(GREEN)
#     eq2[1][13:23].set_color(YELLOW)
#     eq2[0].set_color(BLUE)
#     eq2[1][0].set_color(BLUE)
#     eq2[1][2].set_color(BLUE)
# 
# 
# 
#     self.add(line)
#     self.add(line2)
#     self.play(Write(soh), Write(cah), Write(toa), run_time=2)
#     self.wait(6)
#     self.play(Create(triangle), Create(rectangle), run_time=1.5)
#     self.play(Create(angle), Write(tex), run_time=1)
#     self.play(ReplacementTransform(soh[1].copy() , opp_line))
#     self.wait(0.5)
#     self.play(ReplacementTransform(soh[2].copy() , hyp_line))
#     self.play(Write(eq))
#     self.play(FadeOut(opp_line, hyp_line, eq))
#     self.play(ReplacementTransform(cah[1].copy() , adj_line))
#     self.wait(0.5)
#     self.play(ReplacementTransform(cah[2].copy() , hyp_line))
#     self.play(Write(eq1))
#     self.play(FadeOut(adj_line, hyp_line, eq1))
#     self.play(ReplacementTransform(toa[1].copy() , opp_line))
#     self.wait(0.5)
#     self.play(ReplacementTransform(toa[2].copy() , adj_line))
#     self.play(Write(eq2))
#     self.play(FadeOut(opp_line, adj_line, eq2))

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh Ratio
# 
# class Ratio(Scene):
# 
#   def construct(self):
# 
# 
# 
#     cah = Text("cos", color=GREEN).shift(UP*2.1).scale(1.3)
# 
#     soh = Text("sin", color=RED).next_to(cah, LEFT*8).scale(1.3)
# 
#     toa = Text("tan", color=YELLOW).next_to(cah, RIGHT*8).scale(1.3)
# 
# 
#     line = Line(end=RIGHT*3+UP*0.4, start=LEFT*3+DOWN*3, color=BLACK)
#     line2 = Line(end=RIGHT*3+DOWN*3, start=LEFT*3+DOWN*3, color=BLACK)
# 
#     triangle = Polygon(LEFT*3+DOWN*3,RIGHT*3+DOWN*3, RIGHT*3+UP*0.4, stroke_width=10)
# 
#     rectangle = Square(color = BLUE, stroke_width = 10).shift(RIGHT*2.6+DOWN*2.6).scale(0.4)
# 
#     angle = Angle(line2, line, radius = 1.5, stroke_width = 7, color=YELLOW)
# 
#     tex = MathTex(r"\theta").move_to(angle).shift(RIGHT*0.3+UP*0.1)
# 
#     eq = MathTex(r"{{\sin}}(\theta) = \dfrac{opposite}{hypotenuse}").shift(LEFT*3)
#     eq[1][4:12].set_color(GREEN)
#     eq[1][13:23].set_color(RED)
#     eq[0].set_color(BLUE)
#     eq[1][0].set_color(BLUE)
#     eq[1][2].set_color(BLUE)
# 
# 
# 
#     eq1 = MathTex(r"{{\cos}}(\theta) = \dfrac{adjacent}{hypotenuse}").shift(LEFT*3)
#     eq1[1][4:12].set_color(YELLOW)
#     eq1[1][13:23].set_color(RED)
#     eq1[0].set_color(BLUE)
#     eq1[1][0].set_color(BLUE)
#     eq1[1][2].set_color(BLUE)
# 
# 
# 
# 
#     eq2 = MathTex(r"{{\tan}}(\theta) = \dfrac{opposite}{adjacent}").shift(LEFT*3)
#     eq2[1][4:12].set_color(GREEN)
#     eq2[1][13:23].set_color(YELLOW)
#     eq2[0].set_color(BLUE)
#     eq2[1][0].set_color(BLUE)
#     eq2[1][2].set_color(BLUE)
# 
# 
#     opp_line = Line(start=RIGHT*3+DOWN*3, end = RIGHT*3+UP*0.4, color = GREEN, stroke_width = 20)
#     hyp_line = Line(start=LEFT*3+DOWN*3, end = RIGHT*3+UP*0.4, color = RED, stroke_width = 20)
#     adj_line = Line(start=LEFT*3+DOWN*3, end = RIGHT*3+DOWN*3, color = YELLOW, stroke_width = 20)
# 
# 
#     self.play(Create(triangle), Create(rectangle), run_time=3)
#     self.wait(6)
#     self.play(Write(soh))
#     self.play(Write(cah))
#     self.play(Write(toa))
#     self.wait(2)
#     self.play(Create(angle), FadeOut(soh), FadeOut(cah), FadeOut(toa))
#     self.play(Write(tex), run_time=1)
#     self.wait(1)
#     self.play(Write(eq), Create(opp_line), Create(hyp_line))
#     self.wait(3)
#     self.play(FadeOut(eq, opp_line, hyp_line))
#     self.play(Write(eq1), Create(adj_line), Create(hyp_line))
#     self.wait(3)
#     self.play(FadeOut(eq1, adj_line, hyp_line))
#     self.play(Write(eq2), Create(opp_line), Create(adj_line))
#     self.wait(3)
#     self.play(FadeOut(eq2, opp_line, adj_line))
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh PolygonExample
# 
# 
# 
# class PolygonExample(Scene):
#   def construct(self):
#     pentagon = Polygon(2*UP, RIGHT+UP, RIGHT+DOWN, LEFT+DOWN, LEFT+UP)
#     self.play(Create(pentagon))
#     self.wait(2)
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh Question
# 
# 
# class Question(Scene):
# 
#   def construct(self):
# 
#     i = -7
#     while i <= 7:
# 
#       if i < 0:
#         q = Text("?", color=YELLOW).scale(0.5)
#         q.set_x(i)
#         q.set_y(0.1*(i**2) - 3)
# 
# 
#         t = Text("?", color=YELLOW).scale(0.5)
#         t.set_x(i)
#         t.set_y(-0.1*(i**2) + 3)
#       else:
#         q = Text("?", color=BLUE).scale(0.5)
#         q.set_x(i)
#         q.set_y(0.1*(i**2) - 3)
# 
# 
# 
#         t = Text("?", color=BLUE).scale(0.5)
#         t.set_x(i)
#         t.set_y(-0.1*(i**2) + 3)
# 
#       i += 0.2
# 
# 
# 
#       #self.add(q)
#       #self.add(t)
# 
#       self.play(Write(q), Write(t), run_time = 0.171)
# 
#     big = Text("?").scale(8)
# 
#     self.play(Write(big), run_time=2)

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh Limits
# 
# 
# class Limits(Scene):
# 
#   def construct(self):
# 
# 
#     line = Line(end=RIGHT*3+UP*0.4, start=LEFT*3+DOWN*3, color=BLACK, stroke_width=10)
#     line2 = Line(end=RIGHT*3+DOWN*3, start=LEFT*3+DOWN*3, color=BLACK, stroke_width=10)
# 
#     triangle = Polygon(LEFT*3+DOWN*3,RIGHT*3+DOWN*3, RIGHT*3+UP*0.4, stroke_width=10)
# 
#     rectangle = Square(color = BLUE, stroke_width = 10).shift(RIGHT*2.6+DOWN*2.6).scale(0.4)
# 
#     angle = Angle(line2, line, radius = 1.5, stroke_width = 7, color=YELLOW)
# 
#     tex = MathTex(r"\theta").move_to(angle).shift(RIGHT*0.3+UP*0.1)
# 
# 
#     a = MathTex("A")
#     a.set_x(-3.4)
#     a.set_y(-3)
# 
#     b = MathTex("B")
#     b.set_x(3.4)
#     b.set_y(-3)
# 
# 
#     c = MathTex("C")
#     c.set_x(3.4)
#     c.set_y(0.4)
# 
# 
#     ineq = MathTex(r"0^{\circ}< \theta <90^{\circ}").shift(UP*2.5).scale(1.8)
# 
#     ineq[0][3].set_color(YELLOW)
# 
# 
#     s = MathTex(r"m\angle A + m\angle B + m\angle C = 180 ^{\circ}").shift(UP*2.5).scale(1.8)
# 
#     s[0][2].set_color(YELLOW)
#     s[0][6].set_color(YELLOW)
#     s[0][10].set_color(YELLOW)
# 
#     bb = MathTex(r"m\angle B = 90 ^{\circ}").shift(UP*2.5).scale(1.8)
# 
#     bb[0][2].set_color(YELLOW)
# 
# 
#     self.play(Create(triangle), Create(rectangle), run_time=3)
#     self.play(Write(a), Write(b), Write(c))
#     self.play(Write(s),run_time = 3)
#     self.wait(3.5)
#     self.play(FadeOut(s))
#     self.play(Write(bb))
#     self.play(Create(angle))
#     self.play(Write(tex), run_time=1)
#     self.play(FadeOut(bb))
#     self.play(Write(ineq))
#     self.wait(2)
# 
# 
# 
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim Angless
# 
# 
# import math
# 
# class Angless(Scene):
# 
# 
#   def construct(self):
# 
# 
# 
# 
#     line = Line(start = LEFT*6+DOWN*1.5, end = LEFT*4+DOWN*1.5, color = BLUE, stroke_width=10)
#     line2 = Line(start = LEFT*6.05+DOWN*1.5, end = LEFT*4+DOWN*1.5, color = BLUE, stroke_width=10).rotate(math.radians(90) , about_point=(-6,-1.5,0))
#     angle = Angle(line, line2, radius = 0.8, stroke_width = 7, color=YELLOW)
#     tex = MathTex("\sin (90 ^{\circ})=??").next_to(line, UP*13)
#     tex[0][0:3].set_color(YELLOW)
#     tex[0][9:11].set_color(YELLOW)
# 
# 
#     line3 = Line(start = LEFT*1+DOWN*1.5, end = LEFT*-1+DOWN*1.5, color = BLUE, stroke_width=10)
#     line4 = Line(start = LEFT*1.04+DOWN*1.5, end = LEFT*-1+DOWN*1.5, color = BLUE, stroke_width=10).rotate(math.radians(120) , about_point=(-1,-1.5,0))
#     angle2 = Angle(line3, line4, radius = 0.8, stroke_width = 7, color=YELLOW)
#     tex1 = MathTex("\sin (120 ^{\circ})=??").next_to(line3, UP*13)
#     tex1[0][0:3].set_color(YELLOW)
#     tex1[0][10:12].set_color(YELLOW)
# 
# 
#     line5 = Line(start = LEFT*-4+DOWN*1.5, end = LEFT*-6+DOWN*1.5, color = BLUE, stroke_width=10)
#     line6 = Line(start = LEFT*-3.965+DOWN*1.5, end = LEFT*-6+DOWN*1.5, color = BLUE, stroke_width=10).rotate(math.radians(240) , about_point=(4,-1.5,0))
#     angle3 = Angle(line5, line6, radius = 0.8, stroke_width = 7, color=YELLOW)
#     tex2 = MathTex("\sin (240 ^{\circ})=??").next_to(line5, UP*13)
#     tex2[0][0:3].set_color(YELLOW)
#     tex2[0][10:12].set_color(YELLOW)
# 
#     self.wait(2)
#     self.play(Create(line), Create(line2), Create(angle), Write(tex), run_time=2.5)
#     self.wait(2)
#     self.play(Create(line3), Create(line4), Create(angle2), Write(tex1), run_time=2.5)
#     self.wait(2)
#     self.play(Create(line5), Create(line6), Create(angle3), Write(tex2), run_time=2.5)
#     self.wait(2)
#     #self.add(line3, line4, angle2, tex1)
#     #self.add(line5, line6, angle3, tex2)

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh Funcss
# 
# 
# class Funcss(Scene):
# 
#   def construct(self):
# 
# 
#     cah = Text("cos", color=GREEN).shift(UP*2.1).scale(1.3)
# 
#     soh = Text("sin", color=RED).next_to(cah, LEFT*8).scale(1.3)
# 
#     toa = Text("tan", color=YELLOW).next_to(cah, RIGHT*8).scale(1.3)
# 
#     rat = Text("Ratios", color = BLUE).scale(1.6).next_to(cah, DOWN, buff=1)
# 
#     fff = Text("Functions", color = YELLOW).scale(1.6).next_to(cah, DOWN, buff=1)
# 
#     inout = MathTex(r"x\rightarrow y").scale(1.3).next_to(rat, DOWN, buff = 1.6).scale(1.6)
#     inout[0][1].set_color(YELLOW)
# 
# 
#     self.play(Write(soh), Write(cah), Write(toa))
#     self.wait(3.5)
#     self.play(FadeOut(soh), FadeOut(toa), ReplacementTransform(cah, rat))
#     self.wait(6)
#     self.play(ReplacementTransform(rat, fff))
#     self.wait(1.5)
#     self.play(Write(inout))
#     self.wait(15)
# 
# 
# 
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh RightArcAngleExample
# 
# class RightArcAngleExample(Scene):
#     def construct(self):
#         line1 = Line( LEFT, RIGHT )
#         line2 = Line( DOWN, UP )
#         rightarcangles = [
#             Angle(line1, line2, dot=True),
#             Angle(line1, line2, radius=0.4, quadrant=(1,-1), dot=True, other_angle=True),
#             Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, dot=True, dot_color=YELLOW, dot_radius=0.04, other_angle=True),
#             Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, dot=True, dot_color=GREEN, dot_radius=0.08),
#         ]
#         plots = VGroup()
#         for angle in rightarcangles:
#             plot=VGroup(line1.copy(),line2.copy(), angle)
#             plots.add(plot)
#         plots.arrange(buff=1.5)
#         self.add(plots)

# Commented out IPython magic to ensure Python compatibility.
# %%manim PlaneFadeOut
# 
# class PlaneFadeOut(Scene):
#     def construct(self):
#         sq1 = Square()
#         sq2 = Square()
#         sq3 = Square()
#         sq1.next_to(sq2, LEFT)
#         sq3.next_to(sq2, RIGHT)
#         circ = Circle()
#         circ.next_to(sq2, DOWN)
# 
#         self.add(sq1, sq3, circ)
#         self.wait()
#         self.play(ReplacementTransform(circ, sq2))
#         self.play(FadeOut(sq1), sq2.animate.set_opacity(0), FadeOut(sq3))
#         self.wait()

# Commented out IPython magic to ensure Python compatibility.
# %%manim MovingAngle
# 
# class MovingAngle(Scene):
#     def construct(self):
# 
#         #triangle = Polygon(LEFT*3+DOWN*2,RIGHT*3+DOWN*2, RIGHT*3+UP*0.5, stroke_width=10)
#         rotation_center = LEFT
# 
#         theta_tracker = ValueTracker(30)
#         line1 = Line(LEFT*3+DOWN*2, RIGHT*3+DOWN*2, stroke_width=10, color=BLUE)
#         line_moving = Line(LEFT*3+DOWN*2, RIGHT*3+DOWN*2, stroke_width=10, color=BLUE)
#         line_ref = line_moving.copy()
#         line_moving.rotate(
#             theta_tracker.get_value() * DEGREES, about_point=rotation_center
#         )
#         a = Angle(line1, line_moving, radius=0.5, other_angle=False)
#         tex = MathTex(r"\theta").move_to(
#             Angle(
#                 line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False
#             ).point_from_proportion(0.5)
#         )
# 
#         self.add( line1, line_moving, a, tex)
#         self.wait()
# 
#         line_moving.add_updater(
#             lambda x: x.become(line_ref.copy()).rotate(
#                 theta_tracker.get_value() * DEGREES, about_point=rotation_center
#             )
#         )
# 
#         a.add_updater(
#             lambda x: x.become(Angle(line1, line_moving, radius=0.5, other_angle=False))
#         )
#         tex.add_updater(
#             lambda x: x.move_to(
#                 Angle(
#                     line1, line_moving, radius=0.5 + 3 * SMALL_BUFF, other_angle=False
#                 ).point_from_proportion(0.5)
#             )
#         )
# 
#         self.play(theta_tracker.animate.set_value(80))
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh MovingAngl
# 
# import math
# 
# 
# class MovingAngl(Scene):
#     def construct(self):
# 
#         #triangle = Polygon(LEFT*3+DOWN*2,RIGHT*3+DOWN*2, RIGHT*3+UP*0.5, stroke_width=10)
# 
#         opp_line = Line(start=RIGHT*3+DOWN*3, end = RIGHT*3+UP*0.4, color = GREEN, stroke_width = 20)
#         hyp_line = Line(start=LEFT*3+DOWN*3, end = RIGHT*3+UP*0.4, color = RED, stroke_width = 20)
# 
#         eq = MathTex(r"{{\sin}}(\theta) = \dfrac{opposite}{hypotenuse}").shift(LEFT*3+UP*1)
#         eq[1][4:12].set_color(GREEN)
#         eq[1][13:23].set_color(RED)
#         eq[0].set_color(BLUE)
#         eq[1][0].set_color(BLUE)
#         eq[1][2].set_color(BLUE)
# 
#         new_eq = MathTex(r"{{\sin}}(\theta) = opposite").shift(LEFT*3+UP*1)
#         new_eq[0].set_color(BLUE)
#         new_eq[1][0].set_color(BLUE)
#         new_eq[1][2].set_color(BLUE)
#         new_eq[1][4:12].set_color(GREEN)
# 
#         num = Text("1").scale(1.2).shift(LEFT*0.5+DOWN*0.5)
# 
#         theta_tracker = ValueTracker(math.radians(1))
#         line1 = Line(LEFT*3+DOWN*3, RIGHT*3+DOWN*3, stroke_width=10, color=BLUE)
# 
# 
#         meas = always_redraw(lambda: MathTex(r"\theta =", round(math.degrees(theta_tracker.get_value())) ,r"^{\circ}"  ).shift(RIGHT*3+UP*3))
# 
#         t = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(math.radians(30), about_point=(-3,-3,0))
# 
#         triangle = Polygon(LEFT*3+DOWN*3,RIGHT*3+DOWN*3, t.get_end(), stroke_width=10)
# 
#         rectangle = Square(color = BLUE, stroke_width = 10).shift(RIGHT*2.6+DOWN*2.6).scale(0.4)
# 
#         line_moving = always_redraw(lambda : Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(theta_tracker.get_value(), about_point=(-3,-3,0)))
# 
#         #t_40 = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(theta_tracker.get_value(), about_point=(-3,-3,0))
#         #vertical_line = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=YELLOW, stroke_width=10)
#         #horizontal_line = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=10, color=YELLOW)
# 
# 
#         angle = always_redraw(lambda: Angle(line1, line_moving, radius=1, stroke_width=7, color=YELLOW))
# 
#         tex = always_redraw(lambda: MathTex(r"\theta").next_to(angle).shift(RIGHT*0.05+UP*0.15))
# 
#         #self.play(Create(triangle), Create(rectangle), run_time=2)
#         self.add(line1, line_moving)
#         #self.play(Create(angle), Write(tex))
#         self.play(Write(meas))
#         #self.play(Write(eq) , Create(opp_line), Create(hyp_line))
#         #self.play(Write(num))
#         #self.play(ReplacementTransform(eq, new_eq))
#         #self.play(FadeOut(new_eq), FadeOut(num), FadeOut(opp_line), FadeOut(hyp_line))
# 
# 
#         for i in range(1, 90, 5):
# 
#           self.play(theta_tracker.animate.set_value(math.radians(i)), run_time=0.4)
# 
#           t_40 = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(theta_tracker.get_value(), about_point=(-3,-3,0))
#           vertical_line = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=YELLOW, stroke_width=10)
#           horizontal_line = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=10, color=YELLOW)
#           self.play(Create(vertical_line), Create(horizontal_line), Create(t_40), run_time=0.4)
# 
# 
#         circ = Circle(radius=4*math.sqrt(3), stroke_color=WHITE, stroke_width=12.5).shift(LEFT*3+DOWN*3)
#         self.play(Create(circ), run_time=1.8)
# 
#         #self.play(theta_tracker.animate.set_value(math.radians(70)))
# 
# 
#         #t_40 = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(theta_tracker.get_value(), about_point=(-3,-3,0))
#         #vertical_line = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=YELLOW, stroke_width=10)
#         #horizontal_line = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=10, color=YELLOW)
#         #self.play(Create(vertical_line), Create(horizontal_line))

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh Ang
# 
# import math
# import random
# 
# 
# class Ang(Scene):
#     def construct(self):
# 
#         #triangle = Polygon(LEFT*3+DOWN*2,RIGHT*3+DOWN*2, RIGHT*3+UP*0.5, stroke_width=10)
# 
#         opp_line = Line(start=RIGHT*3+DOWN*3, end = RIGHT*3+UP*0.4, color = GREEN, stroke_width = 20)
#         hyp_line = Line(start=LEFT*3+DOWN*3, end = RIGHT*3+UP*0.4, color = RED, stroke_width = 20)
# 
#         eq = MathTex(r"{{\sin}}(\theta) = \dfrac{opposite}{hypotenuse}").shift(LEFT*3+UP*1)
#         eq[1][4:12].set_color(GREEN)
#         eq[1][13:23].set_color(RED)
#         eq[0].set_color(BLUE)
#         eq[1][0].set_color(BLUE)
#         eq[1][2].set_color(BLUE)
# 
#         new_eq = MathTex(r"{{\sin}}(\theta) = opposite").shift(LEFT*3+UP*1)
#         new_eq[0].set_color(BLUE)
#         new_eq[1][0].set_color(BLUE)
#         new_eq[1][2].set_color(BLUE)
#         new_eq[1][4:12].set_color(GREEN)
# 
#         qqqq = MathTex(r"{{\sin}}(\theta)").shift(LEFT*3.5+UP*1.3).scale(1.8)
#         qqqq[0].set_color(BLUE)
#         qqqq[1][0].set_color(BLUE)
#         qqqq[1][2].set_color(BLUE)
# 
#         num = Text("1").scale(1.2).shift(LEFT*2+UP*1)
# 
#         theta_tracker = ValueTracker(math.radians(30))
#         line1 = Line(LEFT*3+DOWN*3, RIGHT*3+DOWN*3, stroke_width=10, color=BLUE)
# 
# 
#         meas = always_redraw(lambda: MathTex(r"\theta =", round(math.degrees(theta_tracker.get_value())) ,r"^{\circ}"  ).shift(RIGHT*3+UP*3).scale(1.5))
# 
# 
#         t = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(math.radians(30), about_point=(-3,-3,0))
# 
#         triangle = Polygon(LEFT*3+DOWN*3,RIGHT*3+DOWN*3, t.get_end(), stroke_width=10)
# 
#         rectangle = Square(color = BLUE, stroke_width = 10).shift(RIGHT*2.6+DOWN*2.6).scale(0.4)
# 
#         line_moving = always_redraw(lambda : Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLACK).rotate(theta_tracker.get_value(), about_point=(-3,-3,0)))
# 
#         #t_40 = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(theta_tracker.get_value(), about_point=(-3,-3,0))
#         #vertical_line = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=YELLOW, stroke_width=10)
#         #horizontal_line = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=10, color=YELLOW)
# 
# 
#         angle = always_redraw(lambda: Angle(line1, line_moving, radius=1, stroke_width=7, color=YELLOW))
# 
#         tex = always_redraw(lambda: MathTex(r"\theta").next_to(angle).shift(RIGHT*0.05+UP*0.15))
# 
# 
#         circle = Circle(radius = 4*math.sqrt(3), stroke_width=12, color=YELLOW).shift(LEFT*3+DOWN*3)
#         center = Dot(point=(-3,-3,0)).scale(2)
# 
#         #self.add(triangle, rectangle)
#         #self.add(line1, line_moving)
#         #self.add(angle, tex)
#         #self.play(Write(meas))
# 
#         self.add(circle, center)
#         #self.wait(2.5)
# 
# 
#         #self.play(Write(eq) , Create(opp_line), Create(hyp_line))
#         #self.play(Write(num))
#         #self.play(ReplacementTransform(eq, new_eq))
#         #self.play(FadeOut(new_eq), FadeOut(num), FadeOut(opp_line), FadeOut(hyp_line))
# 
# 
# 
# 
#         i = 30 #random.randint(1,89)
# 
# 
#         theta_tracker.set_value(math.radians(i))
#         line_moving = always_redraw(lambda : Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=RED).rotate(theta_tracker.get_value(), about_point=(-3,-3,0)))
#         meas = always_redraw(lambda: MathTex(r"\theta =", round(math.degrees(theta_tracker.get_value())) ,r"^{\circ}"  ).shift(RIGHT*3+UP*3).scale(1.5))
# 
#         line1 = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE)
#         angle = always_redraw(lambda: Angle(line1, line_moving, radius=1, stroke_width=7, color=YELLOW))
# 
#         tex = always_redraw(lambda: MathTex(r"\theta").next_to(angle).shift(RIGHT*0.05+UP*0.15))
# 
#         imp = Dot(point=line_moving.get_end()).scale(3)
# 
#         vertical_lineg = Line(start = line_moving.get_end(), end = (line_moving.get_end()[0],-3, 0), color=GREEN, stroke_width=15)
# 
# 
#         self.add(line1, line_moving)
#         self.add(angle, tex)
#         self.add(meas)
#         self.add(imp)
#         self.wait(2)
#         self.play(Create(vertical_lineg), Write(qqqq), run_time=2.5)
#         self.wait(2)
# 
# 
# 
# 
# 
# 
#           #vertical_line = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=YELLOW, stroke_width=10)
#           #vertical_lineg = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=GREEN, stroke_width=15)
#           #horizontal_line = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=10, color=YELLOW)
#          # horizontal_linew = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=15, color=WHITE)
#         #  self.play(Create(t_40), Write(num))
#         #  self.wait(9.5)
#         #  self.play(Create(vertical_line), Create(horizontal_line), run_time = 3)
#      #     self.play(Create(vertical_lineg))
#        #   self.wait(1)
#     #      self.play(Write(qqqq))
#       #    self.wait(2)
#       #    self.play(FadeOut(vertical_lineg), FadeOut(qqqq))
#       #    self.play(Create(horizontal_linew))
#     #      self.wait(1.5)
#     #      self.play(FadeOut(horizontal_linew))
#     #      self.play(FadeOut(t_40), FadeOut(num))
#    #       self.play(Create(vertical_lineg))
#     #      self.wait(2)
#    #       self.play(Create(horizontal_linew))
# 
# 
# 
#         #self.play(theta_tracker.animate.set_value(math.radians(70)))
# 
# 
#         #t_40 = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(theta_tracker.get_value(), about_point=(-3,-3,0))
#         #vertical_line = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=YELLOW, stroke_width=10)
#         #horizontal_line = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=10, color=YELLOW)
#         #self.play(Create(vertical_line), Create(horizontal_line))

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh Ay
# 
# import math
# import random
# 
# 
# class Ay(Scene):
#     def construct(self):
# 
#         #triangle = Polygon(LEFT*3+DOWN*2,RIGHT*3+DOWN*2, RIGHT*3+UP*0.5, stroke_width=10)
# 
#         opp_line = Line(start=RIGHT*3+DOWN*3, end = RIGHT*3+UP*0.4, color = GREEN, stroke_width = 20)
#         hyp_line = Line(start=LEFT*3+DOWN*3, end = RIGHT*3+UP*0.4, color = RED, stroke_width = 20)
# 
#         eq = MathTex(r"{{\sin}}(\theta) = \dfrac{opposite}{hypotenuse}").shift(LEFT*3+UP*1)
#         eq[1][4:12].set_color(GREEN)
#         eq[1][13:23].set_color(RED)
#         eq[0].set_color(BLUE)
#         eq[1][0].set_color(BLUE)
#         eq[1][2].set_color(BLUE)
# 
#         new_eq = MathTex(r"{{\sin}}(\theta) = opposite").shift(LEFT*3+UP*1)
#         new_eq[0].set_color(BLUE)
#         new_eq[1][0].set_color(BLUE)
#         new_eq[1][2].set_color(BLUE)
#         new_eq[1][4:12].set_color(GREEN)
# 
#         qqqq = MathTex(r"{{\sin}}(\theta)").shift(LEFT*3.5+UP*1.3).scale(1.8)
#         qqqq[0].set_color(BLUE)
#         qqqq[1][0].set_color(BLUE)
#         qqqq[1][2].set_color(BLUE)
# 
#         num = Text("1").scale(1.2).shift(LEFT*2+UP*1)
# 
#         theta_tracker = ValueTracker(math.radians(30))
#         line1 = Line(LEFT*3+DOWN*3, RIGHT*3+DOWN*3, stroke_width=10, color=BLUE)
# 
# 
#         meas = always_redraw(lambda: MathTex(r"\theta =", round(math.degrees(theta_tracker.get_value())) ,r"^{\circ}"  ).shift(RIGHT*3+UP*3).scale(1.5))
# 
#         val = always_redraw(lambda: MathTex(r"\sin (\theta ) = ", round(math.sin(theta_tracker.get_value()) , 2)).shift(LEFT*4+UP*1.8).scale(1.5))
#         t = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(math.radians(30), about_point=(-3,-3,0))
# 
#         triangle = Polygon(LEFT*3+DOWN*3,RIGHT*3+DOWN*3, t.get_end(), stroke_width=10)
# 
#         rectangle = Square(color = BLUE, stroke_width = 10).shift(RIGHT*2.6+DOWN*2.6).scale(0.4)
# 
#         line_moving = always_redraw(lambda : Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLACK).rotate(theta_tracker.get_value(), about_point=(-3,-3,0)))
# 
#         #t_40 = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(theta_tracker.get_value(), about_point=(-3,-3,0))
#         #vertical_line = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=YELLOW, stroke_width=10)
#         #horizontal_line = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=10, color=YELLOW)
# 
# 
#         angle = always_redraw(lambda: Angle(line1, line_moving, radius=1, stroke_width=7, color=YELLOW))
# 
#         tex = always_redraw(lambda: MathTex(r"\theta").next_to(angle).shift(RIGHT*0.05+UP*0.15))
# 
# 
#         circle = Circle(radius = 4*math.sqrt(3), stroke_width=12, color=YELLOW).shift(LEFT*3+DOWN*3)
#         center = Dot(point=(-3,-3,0)).scale(2)
# 
#         #self.add(triangle, rectangle)
#         #self.add(line1, line_moving)
#         #self.add(angle, tex)
#         #self.play(Write(meas))
# 
#         self.add(circle, center)
#         #self.wait(2.5)
# 
# 
#         #self.play(Write(eq) , Create(opp_line), Create(hyp_line))
#         #self.play(Write(num))
#         #self.play(ReplacementTransform(eq, new_eq))
#         #self.play(FadeOut(new_eq), FadeOut(num), FadeOut(opp_line), FadeOut(hyp_line))
# 
# 
# 
# 
#         i = 0.001 #random.randint(1,89)
# 
# 
#         theta_tracker.set_value(math.radians(i))
#         line_moving = always_redraw(lambda : Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=RED).rotate(theta_tracker.get_value(), about_point=(-3,-3,0)))
#         meas = always_redraw(lambda: MathTex(r"\theta =", round(math.degrees(theta_tracker.get_value())) ,r"^{\circ}"  ).shift(RIGHT*3+UP*3).scale(1.5))
# 
#         line1 = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE)
#         angle = always_redraw(lambda: Angle(line1, line_moving, radius=1, stroke_width=7, color=YELLOW))
#         angle2 = always_redraw(lambda: Angle(line1, line_moving, radius=4*math.sqrt(3), stroke_width=15, color=WHITE))
# 
#         tex = always_redraw(lambda: MathTex(r"\theta").next_to(angle).shift(RIGHT*0.05+UP*0.15))
# 
#         imp = Dot(point=line_moving.get_end()).scale(3)
# 
#         vertical_lineg = always_redraw(lambda: Line(start = line_moving.get_end(), end = (line_moving.get_end()[0],-3, 0), color=GREEN, stroke_width=15))
# 
#         self.add(line1, line_moving, angle, angle2, tex, meas, imp, vertical_lineg, val)
#         self.play(theta_tracker.animate.set_value(math.radians(89)), run_time=15)
#         #self.add(line1, line_moving)
#         #self.add(angle, tex)
#         #self.add(meas)
#         #self.add(imp)
#         #self.wait(2)
#         #self.play(Create(vertical_lineg), Write(qqqq), run_time=2.5)
#         #self.wait(2)
# 
# 
# 
# 
# 
# 
#           #vertical_line = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=YELLOW, stroke_width=10)
#           #vertical_lineg = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=GREEN, stroke_width=15)
#           #horizontal_line = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=10, color=YELLOW)
#          # horizontal_linew = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=15, color=WHITE)
#         #  self.play(Create(t_40), Write(num))
#         #  self.wait(9.5)
#         #  self.play(Create(vertical_line), Create(horizontal_line), run_time = 3)
#      #     self.play(Create(vertical_lineg))
#        #   self.wait(1)
#     #      self.play(Write(qqqq))
#       #    self.wait(2)
#       #    self.play(FadeOut(vertical_lineg), FadeOut(qqqq))
#       #    self.play(Create(horizontal_linew))
#     #      self.wait(1.5)
#     #      self.play(FadeOut(horizontal_linew))
#     #      self.play(FadeOut(t_40), FadeOut(num))
#    #       self.play(Create(vertical_lineg))
#     #      self.wait(2)
#    #       self.play(Create(horizontal_linew))
# 
# 
# 
#         #self.play(theta_tracker.animate.set_value(math.radians(70)))
# 
# 
#         #t_40 = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(theta_tracker.get_value(), about_point=(-3,-3,0))
#         #vertical_line = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=YELLOW, stroke_width=10)
#         #horizontal_line = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=10, color=YELLOW)
#         #self.play(Create(vertical_line), Create(horizontal_line))

# Commented out IPython magic to ensure Python compatibility.
# %%manim -pqh An
# 
# import math
# 
# 
# class An(Scene):
#     def construct(self):
# 
#         #triangle = Polygon(LEFT*3+DOWN*2,RIGHT*3+DOWN*2, RIGHT*3+UP*0.5, stroke_width=10)
# 
#         opp_line = Line(start=RIGHT*3+DOWN*3, end = RIGHT*3+UP*0.4, color = GREEN, stroke_width = 20)
#         hyp_line = Line(start=LEFT*3+DOWN*3, end = RIGHT*3+UP*0.4, color = RED, stroke_width = 20)
# 
#         eq = MathTex(r"{{\sin}}(\theta) = \dfrac{opposite}{hypotenuse}").shift(LEFT*3+UP*1)
#         eq[1][4:12].set_color(GREEN)
#         eq[1][13:23].set_color(RED)
#         eq[0].set_color(BLUE)
#         eq[1][0].set_color(BLUE)
#         eq[1][2].set_color(BLUE)
# 
#         new_eq = MathTex(r"{{\sin}}(\theta) = opposite").shift(LEFT*3+UP*1)
#         new_eq[0].set_color(BLUE)
#         new_eq[1][0].set_color(BLUE)
#         new_eq[1][2].set_color(BLUE)
#         new_eq[1][4:12].set_color(GREEN)
# 
#         qqqq = MathTex(r"{{\sin}}(\theta)").shift(LEFT*3.5+UP*3).scale(1.5)
#         qqqq[0].set_color(BLUE)
#         qqqq[1][0].set_color(BLUE)
#         qqqq[1][2].set_color(BLUE)
# 
#         num = Text("1").scale(1.2).shift(LEFT*2+UP*1)
# 
#         theta_tracker = ValueTracker(math.radians(30))
#         line1 = Line(LEFT*3+DOWN*3, RIGHT*3+DOWN*3, stroke_width=10, color=BLUE)
# 
# 
#         meas = always_redraw(lambda: MathTex(r"\theta =", round(math.degrees(theta_tracker.get_value())) ,r"^{\circ}"  ).shift(RIGHT*3+UP*3).scale(1.5))
# 
# 
#         t = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(math.radians(30), about_point=(-3,-3,0))
# 
#         triangle = Polygon(LEFT*3+DOWN*3,RIGHT*3+DOWN*3, t.get_end(), stroke_width=10)
# 
#         rectangle = Square(color = BLUE, stroke_width = 10).shift(RIGHT*2.6+DOWN*2.6).scale(0.4)
# 
#         line_moving = always_redraw(lambda : Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(theta_tracker.get_value(), about_point=(-3,-3,0)))
# 
#         #t_40 = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(theta_tracker.get_value(), about_point=(-3,-3,0))
#         #vertical_line = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=YELLOW, stroke_width=10)
#         #horizontal_line = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=10, color=YELLOW)
# 
# 
#         angle = always_redraw(lambda: Angle(line1, line_moving, radius=1, stroke_width=7, color=YELLOW))
# 
#         tex = always_redraw(lambda: MathTex(r"\theta").next_to(angle).shift(RIGHT*0.05+UP*0.15))
# 
#         self.add(triangle, rectangle)
#         self.add(line1, line_moving)
#         self.add(angle, tex)
#         self.play(Write(meas))
#         self.wait(2.5)
# 
# 
#         #self.play(Write(eq) , Create(opp_line), Create(hyp_line))
#         #self.play(Write(num))
#         #self.play(ReplacementTransform(eq, new_eq))
#         #self.play(FadeOut(new_eq), FadeOut(num), FadeOut(opp_line), FadeOut(hyp_line))
# 
# 
#         for i in [60]:
# 
#           self.play(theta_tracker.animate.set_value(math.radians(i)), run_time=5)
# 
# 
#           t_40 = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=RED).rotate(theta_tracker.get_value(), about_point=(-3,-3,0))
#           vertical_line = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=YELLOW, stroke_width=10)
#           vertical_lineg = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=GREEN, stroke_width=15)
#           horizontal_line = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=10, color=YELLOW)
#           horizontal_linew = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=15, color=WHITE)
#           self.play(Create(t_40), Write(num))
#           self.wait(9.5)
#           self.play(Create(vertical_line), Create(horizontal_line), run_time = 3)
#           self.play(Create(vertical_lineg))
#           self.wait(1)
#           self.play(Write(qqqq))
#           self.wait(2)
#           self.play(FadeOut(vertical_lineg), FadeOut(qqqq))
#           self.play(Create(horizontal_linew))
#           self.wait(1.5)
#           self.play(FadeOut(horizontal_linew))
#           self.play(FadeOut(t_40), FadeOut(num))
#           self.play(Create(vertical_lineg))
#           self.wait(2)
#           self.play(Create(horizontal_linew))
# 
# 
# 
#         #self.play(theta_tracker.animate.set_value(math.radians(70)))
# 
# 
#         #t_40 = Line((-3,-3,0), (-3+4*math.sqrt(3), -3, 0), stroke_width=10, color=BLUE).rotate(theta_tracker.get_value(), about_point=(-3,-3,0))
#         #vertical_line = Line(start = t_40.get_end(), end = (t_40.get_end()[0],-3, 0), color=YELLOW, stroke_width=10)
#         #horizontal_line = Line(start = vertical_line.get_end() , end = (-3,-3,0), stroke_width=10, color=YELLOW)
#         #self.play(Create(vertical_line), Create(horizontal_line))

# Commented out IPython magic to ensure Python compatibility.
# %%manim Testing
# 
# 
# class Testing(Scene):
#   def construct(self):
#     equation = MathTex(r"{{\sin}}(\theta) = opposite")
# 
#     self.add(equation, index_labels(equation[1]))

class Confusion(Scene):

  def construct(self):


    sin = Text("sin()?", color=YELLOW).shift(UP*2+LEFT*2)
    cos = Text("cos()?", color=BLUE).shift(UP*2)
    sin = Text("tan()?", color=GREEN).shift(UP*2+RIGHT*2)

# Commented out IPython magic to ensure Python compatibility.
# %%manim CCC
# import math
# 
# class CCC(Scene):
# 
# 
# 
# 
#   def construct(self):
# 
# 
#     text = MarkupText(f'Definition<span fgcolor="{BLUE}"> of a Circle</span>', color=YELLOW).scale(1.6)
#     line = Line(stroke_width = 15).shift(UP*1.55)
#     line.set_length(9)
# 
#     theta_tracker = ValueTracker(math.radians(0.001))
# 
# 
#     circle_blank = Circle(radius=1, stroke_color=BLACK)
#     d = Dot(point = (0, -1.5, 0))
# 
#     line1 = Line(start=(0,-1.5,0), end=(2,-1.5,0), stroke_width=10, color=BLACK)
# 
# 
# 
#     line_moving = always_redraw(lambda : Line(start = (0,-1.5,0), end = (2,-1.5, 0), stroke_width=10, color=BLUE).rotate(theta_tracker.get_value(), about_point=(0,-1.5,0)))
# 
# 
#     angle = always_redraw(lambda: Angle(line1, line_moving, radius=2, stroke_width=7, color=YELLOW))
# 
# 
#     dot = always_redraw(lambda: Dot(point=line_moving.get_end()))
# 
#     dis = Text("Distance = Radius", t2c={"Radius": BLUE}).shift(UP*1.7)
#     po = Text("Point = Center", t2c={"Center": YELLOW}).shift(UP*1.7)
# 
#     self.wait(1.5)
#     self.play(Write(text), run_time=1.5)
#     self.wait(1)
#     self.play(text.animate.shift(UP*2.2).scale(0.8))
#     self.play(Create(line))
#     self.add(circle_blank, line1)
#     self.play(Create(d))
#     self.play(Create(line_moving))
#     self.play(Create(dot))
#     self.play(Create(angle))
#     self.play(theta_tracker.animate.set_value(math.radians(360)), run_time=3)
#     self.play(FadeOut(text), FadeOut(line))
#     self.play(Write(dis))
#     self.play(ReplacementTransform(dis, po))
#     self.wait(2)
#

# Commented out IPython magic to ensure Python compatibility.
# %%manim Rephrase
# 
# 
# 
# class Rephrase(Scene):
# 
#   def construct(self):
# 
# 
# 
#        text = MarkupText(f'Thank You for <span fgcolor="{BLUE}">Watching!</span>', color=YELLOW).scale(1.3)
#        #inout = MathTex(r"x\rightarrow y").scale(1.3).next_to(text, DOWN, buff = 1.6).scale(1.6)
#        #inout[0][1].set_color(YELLOW)
# 
# 
#        self.play(Write(text), run_time=2.5)
#        self.wait(2)

